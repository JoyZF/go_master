# OSI参考模型

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

# TCP/IP协议栈

- 应用层
- 传输层 （TCP UDP）
- 网际层 (IPV4 IPV6)
- 网络接口层

![](https://static001.geekbang.org/resource/image/cb/b4/cb34e0e3b7769498ea703fe6231201b4.png)

# 为什么要三次握手？

这个问题的本质是，信道不可靠，但是通讯双方需要就某个问题达成一致，而要解决这个问题，无论你在消息中包含什么信息，三次通讯是理论上的最小值，所以三次握手不是TCP本身的要求，而是为了满足“在不可靠信道上可靠地传输信息”这一需求所导致的。

TCP链接的双方需要确保各自的收发消息的能力都是正常的。

客户端第一次发送握手消息到服务端，
服务端接收到握手消息后把ack和自己的syn一同发送给客户端，这是第二次握手，
当客户端接收到服务端发送来的第二次握手消息后，客户端可以确认*“服务端的收发能力OK，客户端的收发能力OK”*，但是服务端只能确认*“客户端的发送OK，服务端的接收OK”*，
所以还需要第三次握手，客户端收到服务端的第二次握手消息后，发起第三次握手消息，服务端收到客户端发送的第三次握手消息后，就能够确定*“服务端的发送OK，客户端的接收OK”*，
至此，客户端和服务端都能够确认自己和对方的收发能力OK，，tcp连接建立完成。

### 进程间通信常用本地套接字进行通信。

- 本地套接字的编程接口和IPV4 、 IPV6 套接字编程接口是一致的，支持字节流和字节报两种协议 （TCP、UDP）
- 本地套接字的实现效率大大高于IPV4 、 IPV6 的字节流和数据报套接字的实现。

# 常用工具

- ping
- ifconfig
- netstat 
- lsof
- tcpdump

# TIME WAIT 的作用

![](https://static001.geekbang.org/resource/image/94/5f/945c60ae06d282dcc22ad3b868f1175f.png)

在主机2发送的FIN开始到主机2接收主机1的ACK这段时间会变成TIME WAIT状态。如果主机2重发FIN，TIME WAIT 会重新计时。 确保主机2能够接收到ACK，得以自然关闭。

- TIME WAIT 的引入是为了让TCP报文得以自然消失，同时为了让被动关闭方能够正常关闭。
- 不要试图使用SO_LINGER设置套接字选项，跳过TIME_WAIT

# select 、 poll 、 epoll

select 与golang的select 同理，创建了多条路处理不同的事件(如read、write 、send)。但是有1024个df的限制

poll 解决了select 1024fd的限制

epoll 使用边缘触发，减少了用户态和内核态的上下文切换，进一步提升了性能。

这三种I/O多路复用机制都是同步非阻塞的I/O

异步多路复用机制只有AI/O



