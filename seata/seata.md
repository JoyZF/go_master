# Seata learn log

Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。

Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。

![](https://user-images.githubusercontent.com/68344696/145942191-7a2d469f-94c8-4cd2-8c7e-46ad75683636.png)



## 事务模式简介
### AT模式

前提：

- 基于支持本地ACID事务的关系型数据库（MySQL）

### 写隔离

- 一阶段本地事务提交前，要确保先拿到全局锁
- 拿不到全局锁，不能提交本地事务
- 拿全局锁的尝试被限制在一定范围内，超过范围将放弃，并回滚本地事务，释放本地锁。

example:

两个全局事务tx1和tx2，分别对a表的m字段进行更新操作，m的初始值1000。

tx1先开始，开启本地事务，拿到本地锁，更新操作m=1000-100 = 900。本地事务释放本地锁。tx2后开始，开启本地事务，拿到本地锁，更新操作m=900-100=800。本地事务提交前，尝试拿该记录的全局锁，tx1全局提交前，该记录的全局锁被tx1持有，tx需要重试等待全局锁。

![](https://img.alicdn.com/tfs/TB1zaknwVY7gK0jSZKzXXaikpXa-702-521.png)

tx1 二阶段全局提交，释放 **全局锁** 。tx2 拿到 **全局锁** 提交本地事务。

![](https://img.alicdn.com/tfs/TB1xW0UwubviK0jSZFNXXaApXXa-718-521.png)

如果tx1的二阶段全局回滚，则tx1需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支回滚。

此时，如果tx2仍在等待该数据的全局锁，同时持有本地锁，则tx1的分支回滚会失败。分支的回滚会一直重试，直到tx2的全局锁等锁超时，放弃全局锁并回滚本地事务释放锁，tx1的分支回滚最终成功。

因为整个过程 **全局锁** 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 **脏写** 的问题。

### 读隔离





### TCC模式
Try Confirm Cancel 
### SAGA模式
Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某个参与者失败则补偿前面以及成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。

![](https://img.alicdn.com/tfs/TB1Y2kuw7T2gK0jSZFkXXcIQFXa-445-444.png)

适用场景：
- 业务流程长、业务流程多
- 参与者包含其他公司或遗留系统服务，无法提供TCC模式要求的三个接口

优势：
- 一阶段提交本地事务，无锁，高性能
- 事件驱动架构，参与者可异步执行，高吞吐
- 补偿服务易于实现

缺点：
- 不保证隔离性（应对方案见[文档](https://seata.io/zh-cn/docs/user/saga.html)）
### XA

// todo XA 延伸 MySQL 内部XA 和 外部XA


## reference
