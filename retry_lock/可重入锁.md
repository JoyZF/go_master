#  可重入锁

## 什么是可重入锁

可重入锁又称递归锁，指同一个线程在外层方法获取到所得时候，在进入该方法内层方法时自动会获取锁。不会因为之前获取过还没有释放而阻塞。



假设现在有多个村民在水井排队打水，有管理员正在看管这口水井，村民在打水时，管理员允许锁和同一个人的多个水桶绑定，这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。
![](https://img-blog.csdnimg.cn/img_convert/f3139378641ec2ab1a119900befb2630.png)

如果是非可重入锁，，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。

![](https://img-blog.csdnimg.cn/img_convert/8d868b5a7a0721953673f4aac168a473.png)

了解概念之后我们再来了解一下Go语言中为什么没有可重入锁。

Russ Cox 认为：当我们调用mutex.Lock（）时，我们需要保证在调用它的上下文中能够保持变量的不变性，而点那个我们调用mutex.Unlock（）的时候，我们可以保证以下两件事：

- 我们不再需要保持这种不变性
- 如果我在使用mutex期间破坏了这种不变性，那么我已经将其恢复了。

Russ Cox 认为可重入锁容易产生bug。